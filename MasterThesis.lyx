#LyX 2.0 created this file. For more info see http://www.lyx.org/
\lyxformat 413
\begin_document
\begin_header
\textclass apa6
\begin_preamble
\usepackage[american]{babel}
\usepackage{csquotes}
\usepackage[style=apa,natbib=true,backend=biber]{biblatex}
\DeclareLanguageMapping{american}{american-apa}
\addbibresource{/Users/jan/Studium/Masterarbeit/Thesis/MasterThesis.bib}
\end_preamble
\use_default_options true
\begin_modules
knitr
biblatex
\end_modules
\maintain_unincluded_children false
\language english
\language_package default
\inputencoding utf8
\fontencoding global
\font_roman default
\font_sans default
\font_typewriter default
\font_default_family default
\use_non_tex_fonts false
\font_sc false
\font_osf false
\font_sf_scale 100
\font_tt_scale 100

\graphics default
\default_output_format default
\output_sync 0
\bibtex_command biber
\index_command default
\paperfontsize default
\spacing single
\use_hyperref false
\papersize a4paper
\use_geometry false
\use_amsmath 1
\use_esint 1
\use_mhchem 1
\use_mathdots 1
\cite_engine natbib_authoryear
\use_bibtopic false
\use_indices false
\paperorientation portrait
\suppress_date false
\use_refstyle 1
\index Index
\shortcut idx
\color #008000
\end_index
\secnumdepth 3
\tocdepth 3
\paragraph_separation indent
\paragraph_indentation default
\quotes_language english
\papercolumns 1
\papersides 1
\paperpagestyle default
\tracking_changes false
\output_changes false
\html_math_output 0
\html_css_as_file 0
\html_be_strict false
\end_header

\begin_body

\begin_layout ShortTitle
Recognition Memory
\end_layout

\begin_layout Title
Disentangling Cognitive Processes with Mathematical Modeling:
\emph on
 Evaluating Continuous and Discrete-State Models of Recognition Memory via
 Response-Scale and Encoding-Strength Manipulation
\end_layout

\begin_layout Author
Jan Vogt
\end_layout

\begin_layout Abstract
Abstract
\end_layout

\begin_layout Standard
\begin_inset CommandInset toc
LatexCommand tableofcontents

\end_inset


\end_layout

\begin_layout Section
Introduction
\end_layout

\begin_layout Standard
...
\end_layout

\begin_layout Section
Theory
\end_layout

\begin_layout Standard
\begin_inset CommandInset citation
LatexCommand citet
key "province_evidence_2012"

\end_inset

 are great! 
\begin_inset CommandInset citation
LatexCommand cite
key "broder_recognition_2009"

\end_inset


\end_layout

\begin_layout Section
Methods and Materials
\end_layout

\begin_layout Standard
...
\end_layout

\begin_layout Section
Results
\end_layout

\begin_layout Standard
...nnn
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

<<includes, echo=FALSE, eval=TRUE>>=
\end_layout

\begin_layout Plain Layout

suppressMessages(library(plyr))
\end_layout

\begin_layout Plain Layout

suppressMessages(library(ggplot2))
\end_layout

\begin_layout Plain Layout

suppressMessages(library(reshape))
\end_layout

\begin_layout Plain Layout

suppressMessages(library(gridExtra))
\end_layout

\begin_layout Plain Layout

suppressMessages(library(MPTinR))
\end_layout

\begin_layout Plain Layout

<<DataManipulation>>
\end_layout

\begin_layout Plain Layout

<<ModelFitting>>
\end_layout

\begin_layout Plain Layout

<<ModelSpecifications>>
\end_layout

\begin_layout Plain Layout

@
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

<<dataSetup, cache=TRUE, echo=FALSE, eval=TRUE>>=
\end_layout

\begin_layout Plain Layout

rec.data <- read.csv(file="data/Rec.csv", sep=";")
\end_layout

\begin_layout Plain Layout

dists.list <- emp.dists(rec.data)
\end_layout

\begin_layout Plain Layout

fit.data <- do.fitting(dists.list, EVSDT, UVSDT, MPT2HTM, MPT1HTM2g)
\end_layout

\begin_layout Plain Layout

dists.list <- fit.data$data
\end_layout

\begin_layout Plain Layout

model.param <- fit.data$fit.par
\end_layout

\begin_layout Plain Layout

model.comp <- fit.data$model.comp
\end_layout

\begin_layout Plain Layout

@
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

<<visualisation, echo=TRUE, eval=TRUE, warning=FALSE, out.extra='angle=90',
 fig.width=14, fig.height=9>>=
\end_layout

\begin_layout Plain Layout

#model.comp[[1]][[2]]
\end_layout

\begin_layout Plain Layout

#plot.in.chunks(dists.list[[1]][[1]], 1)
\end_layout

\begin_layout Plain Layout

#plot.in.chunks(dists.list[[1]][[2]], 8)
\end_layout

\begin_layout Plain Layout

#plot.in.chunks(dists.list[[2]][[1]], 4)
\end_layout

\begin_layout Plain Layout

#plot.in.chunks(dists.list[[2]][[2]], 8)
\end_layout

\begin_layout Plain Layout

#foreach.vp(dists.list[[1]][[1]], plot.vp, model.param[[1]][[1]], echo=FALSE)
\end_layout

\begin_layout Plain Layout

#foreach.vp(dists.list[[1]][[2]], plot.vp, model.param[[1]][[2]], echo=FALSE)
\end_layout

\begin_layout Plain Layout

#foreach.vp(dists.list[[2]][[1]], plot.vp, model.param[[2]][[1]], echo=FALSE)
\end_layout

\begin_layout Plain Layout

#foreach.vp(dists.list[[2]][[2]], plot.vp, model.param[[2]][[2]], echo=FALSE)
\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\begin_layout Standard
First, the individual probability distributions for each condition is calculated.
\end_layout

\begin_layout Standard
\begin_inset Formula $x\in\{x\vert x\in\mathbb{Z}\wedge x\geq=0\wedge x<\text{\#points of rating scale}\}$
\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula $P(X=x\vert e\in E,\, s\in S,\, p\in P)=\begin{cases}
d_{e}\prod_{k=x+1}^{k<5}(1-dd_{sk})\prod_{k=x}^{3<k\leq x}(dd_{sk})+(1-d{}_{e})g_{p}\prod(1-gd_{s})\prod(gd_{s})\end{cases}$
\end_inset

 
\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
m_{Gij}=\begin{cases}
\theta j & \text{if }j=i<\left|I\right|\\
1-\theta j & \text{if }j>i\\
1 & \text{else}
\end{cases}
\]

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
\]

\end_inset


\end_layout

\begin_layout Section
Conclusions
\end_layout

\begin_layout Standard
...
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
printbibliography
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Plain Layout
\begin_inset CommandInset bibtex
LatexCommand bibtex
bibfiles "MasterThesis"
options "plain"

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Section
Appendix
\end_layout

\begin_layout Subsection
Data Manipulation Code
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

<<DataManipulation, eval=FALSE, echo=TRUE>>=
\end_layout

\begin_layout Plain Layout

emp.dists <- function(x){
\end_layout

\begin_layout Plain Layout

  x <- cbind(x, model="empirical")
\end_layout

\begin_layout Plain Layout

  cast.formula <- code+session+scale+enc+posold+model~result_variable   
\end_layout

\begin_layout Plain Layout

  value.name <- "resp"
\end_layout

\begin_layout Plain Layout

  ret.list <- list(cast(filter(x, 1), cast.formula, probabilityDist, value=value.na
me), cast(filter(x, 2), cast.formula, probabilityDist, value=value.name))
 
\end_layout

\begin_layout Plain Layout

  names(ret.list) <- c("normal", "forcedguess")
\end_layout

\begin_layout Plain Layout

  ret.list <- lapply(ret.list, rename.and.melt, 1:7, value.name)
\end_layout

\begin_layout Plain Layout

  ret.list <- lapply(ret.list, split.sessions)
\end_layout

\begin_layout Plain Layout

  return(ret.list) 
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

probabilityDist = function(x){   
\end_layout

\begin_layout Plain Layout

  x.freq <- table(x)
\end_layout

\begin_layout Plain Layout

  x.relfreq <- vector(length=length(x.freq)+1)
\end_layout

\begin_layout Plain Layout

  x.relfreq[1] <- length(x)
\end_layout

\begin_layout Plain Layout

  # Empty cell correction:
\end_layout

\begin_layout Plain Layout

  #x.relfreq[-1] <- (x.freq+(0.5/length(x.freq))) / (length(x)+0.5)
\end_layout

\begin_layout Plain Layout

  # No empty Cell correction
\end_layout

\begin_layout Plain Layout

  x.relfreq[-1] <- x.freq / length(x)
\end_layout

\begin_layout Plain Layout

  names(x.relfreq)[1] <- "ntrials"
\end_layout

\begin_layout Plain Layout

  names(x.relfreq)[-1] <- names(x.freq)
\end_layout

\begin_layout Plain Layout

  return(x.relfreq) 
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

filter <- function(x, group){
\end_layout

\begin_layout Plain Layout

  groupName <- switch(group, "normal"="normal", "forcedguess"="forcedguess")
\end_layout

\begin_layout Plain Layout

  x.ret <- x[x$group==groupName,]
\end_layout

\begin_layout Plain Layout

  x.ret$resp <- factor(x.ret$resp, levels=if(group==1) 0:7  else  0:5)   
\end_layout

\begin_layout Plain Layout

  return(x.ret) 
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

split.sessions <- function(x){
\end_layout

\begin_layout Plain Layout

  return(list(words=x[x$session==0,], images=x[x$session==1,]))
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

rename.and.melt <- function(x, melt.id, variable.name){ 
\end_layout

\begin_layout Plain Layout

  #  names(x)[match(paste("X",0:7,sep=""),names(x), nomatch=0)] <- as.character(0
:7)
\end_layout

\begin_layout Plain Layout

  x <- melt.data.frame(x, melt.id)
\end_layout

\begin_layout Plain Layout

  names(x)[names(x)=="result_variable"]<-variable.name   
\end_layout

\begin_layout Plain Layout

  return(x) 
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Model Fitting
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

<<ModelFitting, eval=FALSE, echo=TRUE>>=
\end_layout

\begin_layout Plain Layout

#A model is a function returning a list of functions.
 
\end_layout

\begin_layout Plain Layout

#The first element is the model's name as single element character vector
\end_layout

\begin_layout Plain Layout

#The second to the third to last functions are called with an equal-length
 factors for each: 
\end_layout

\begin_layout Plain Layout

# function(resp, enc, scale, posold)
\end_layout

\begin_layout Plain Layout

#and are exprected to return a same-length vector.
\end_layout

\begin_layout Plain Layout

#The next to last function is a function(...) of all the previosly returned
 vectors and is expected to return a character vector of same length as
 its arguments representing specifying the model.
\end_layout

\begin_layout Plain Layout

#The last function(data, model.filename, parameter, ...) is exprected to return
 an mptinr fit result based on it's parameters)
\end_layout

\begin_layout Plain Layout

#Model boilerplate:
\end_layout

\begin_layout Plain Layout

#NAME <- function(){
\end_layout

\begin_layout Plain Layout

#   a <- function(resp, enc, scale, posold){
\end_layout

\begin_layout Plain Layout

#     return(resp)
\end_layout

\begin_layout Plain Layout

#   }
\end_layout

\begin_layout Plain Layout

#   model.description <- function(a){
\end_layout

\begin_layout Plain Layout

#     return(a)
\end_layout

\begin_layout Plain Layout

#   }
\end_layout

\begin_layout Plain Layout

#   fit.call <- function(data, model.filename, parameter, ...){
\end_layout

\begin_layout Plain Layout

#     return(fit.model(data, model.filename, ...))
\end_layout

\begin_layout Plain Layout

#   }
\end_layout

\begin_layout Plain Layout

#   return(list("NAME", a, model.description, fit.call))
\end_layout

\begin_layout Plain Layout

# }
\end_layout

\begin_layout Plain Layout

do.fitting <- function(data, ...){
\end_layout

\begin_layout Plain Layout

  ret.val.list <- lapply(data, lapply, multi.gen.fit.models, ...)
\end_layout

\begin_layout Plain Layout

  ret.dists <- lapply(ret.val.list, lapply, "[[", "data")
\end_layout

\begin_layout Plain Layout

  ret.dists <- mapply(function(x,y) mapply(rbind, x, y), ret.dists, data)
\end_layout

\begin_layout Plain Layout

  ret.pars <- lapply(ret.val.list, lapply, "[[", "fit.par")
\end_layout

\begin_layout Plain Layout

  ret.comp <- lapply(ret.val.list, lapply, "[[", "model.comp")
\end_layout

\begin_layout Plain Layout

  return(list(data=ret.dists, fit.par=ret.pars, model.comp=ret.comp))
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

multi.gen.fit.models <- function(data, ...){
\end_layout

\begin_layout Plain Layout

  models <- list(...)
\end_layout

\begin_layout Plain Layout

  model.res.list <- lapply(models, multi.gen.fit.model, data[data$model=="empirical",
])
\end_layout

\begin_layout Plain Layout

  predicted.data.list <- lapply(model.res.list, "[[", "data")
\end_layout

\begin_layout Plain Layout

  predicted.data.df <- do.call(rbind, predicted.data.list)
\end_layout

\begin_layout Plain Layout

  mptinr.res.list <- lapply(model.res.list, "[[", "mptinr")
\end_layout

\begin_layout Plain Layout

  names(mptinr.res.list) <- vapply(models, function(x) x()[[1]], "")
\end_layout

\begin_layout Plain Layout

  fit.par.list <- mapply(function(x, name) extract.multi.mptinr.results(name,
 x), mptinr.res.list, names(mptinr.res.list))
\end_layout

\begin_layout Plain Layout

  fit.par <- do.call(cbind, fit.par.list)
\end_layout

\begin_layout Plain Layout

  fit.par <- cbind(code=row.names(fit.par), fit.par)
\end_layout

\begin_layout Plain Layout

  select.res <- select.mpt(mptinr.res.list)
\end_layout

\begin_layout Plain Layout

  return(list(data=predicted.data.df, fit.par=fit.par, model.comp=select.res))
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

multi.gen.fit.model <- function(model.gen, data.df, ..., resp=variable, enc=enc,
 scale=scale, posold=posold, model=model, split.by=code, prob=value, ntrials=ntri
als){
\end_layout

\begin_layout Plain Layout

  model.list <- model.gen()
\end_layout

\begin_layout Plain Layout

  par.vec.fun.list <- model.list[2:(length(model.list)-2)]
\end_layout

\begin_layout Plain Layout

  model.func <- model.list[[length(model.list)-1]]
\end_layout

\begin_layout Plain Layout

  fit.func <- model.list[[length(model.list)]]
\end_layout

\begin_layout Plain Layout

  mc <- match.call()
\end_layout

\begin_layout Plain Layout

  mc[[1]] <- gen.model
\end_layout

\begin_layout Plain Layout

  model.file <- eval.parent(mc[c(-4,-8)])
\end_layout

\begin_layout Plain Layout

  mc[[1]] <- sort.data
\end_layout

\begin_layout Plain Layout

  data.df[,as.character(substitute(value))] <- data.df[,as.character(substitute(valu
e))]*data.df[,as.character(substitute(ntrials))]
\end_layout

\begin_layout Plain Layout

  sorted.df.list <- by(data.df, factor(data.df[[as.character(substitute(split.by))]]),
 function(x, mc, model.name){
\end_layout

\begin_layout Plain Layout

    mc[[3]] <- x[x[[model.name]]=="empirical",]
\end_layout

\begin_layout Plain Layout

    eval.parent(mc[c(-2,-4,-8)])
\end_layout

\begin_layout Plain Layout

  },
\end_layout

\begin_layout Plain Layout

                       mc,
\end_layout

\begin_layout Plain Layout

                       as.character(substitute(model)),
\end_layout

\begin_layout Plain Layout

                       simplify=FALSE)
\end_layout

\begin_layout Plain Layout

  data.mat <- vapply(sorted.df.list, function(x, value.name) x[[value.name]],
 1:length(model.file[model.file!=""])*1.0, as.character(substitute(value)))
\end_layout

\begin_layout Plain Layout

  mptinr.res <- fit.func(data=t(data.mat), textConnection(model.file), parameter=che
ck.mpt(textConnection(model.file))$parameters, ...)
\end_layout

\begin_layout Plain Layout

  ret.df <- do.call(rbind, sorted.df.list)
\end_layout

\begin_layout Plain Layout

  predicted.data.vec <- t(mptinr.res$data$predicted$individual)
\end_layout

\begin_layout Plain Layout

  attr(predicted.data.vec, "dim") <- NULL
\end_layout

\begin_layout Plain Layout

  ret.df[,as.character(substitute(value))] <- predicted.data.vec
\end_layout

\begin_layout Plain Layout

  ret.df[,as.character(substitute(model))] <- model.list[[1]]
\end_layout

\begin_layout Plain Layout

  row.names(ret.df) <- NULL
\end_layout

\begin_layout Plain Layout

  return(list(data=ret.df, mptinr=mptinr.res))
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

#posold needs to be a factor with first level meaning 'left' and last level
 meaning 'rigth'
\end_layout

\begin_layout Plain Layout

#returns a ready to use character vector decribing the model for mptinr
\end_layout

\begin_layout Plain Layout

gen.model <- function(model.gen, data.df, resp=variable, enc=enc, scale=scale,
 posold=posold){
\end_layout

\begin_layout Plain Layout

  mc <- match.call()
\end_layout

\begin_layout Plain Layout

  mc[[1]] <- as.name("gen.datapoints")
\end_layout

\begin_layout Plain Layout

  data.df <- eval.parent(mc[-2])
\end_layout

\begin_layout Plain Layout

  model.list <- model.gen()
\end_layout

\begin_layout Plain Layout

  par.vec.fun.list <- model.list[2:(length(model.list)-2)]
\end_layout

\begin_layout Plain Layout

  model.func <- model.list[[length(model.list)-1]]
\end_layout

\begin_layout Plain Layout

  par.vec.list <- lapply(par.vec.fun.list, do.call, list(resp=data.df$resp, enc=data.df$
enc, scale=data.df$scale, posold=data.df$posold))
\end_layout

\begin_layout Plain Layout

  tmp.model <- do.call(model.func, par.vec.list)
\end_layout

\begin_layout Plain Layout

  #print(paste("Generated", model.list[[1]], ":"))
\end_layout

\begin_layout Plain Layout

  #print(cbind(data.df, tmp.model))
\end_layout

\begin_layout Plain Layout

  n.states <- length(levels(data.df$resp))
\end_layout

\begin_layout Plain Layout

  final.model <- vapply(1:(nrow(data.df)/n.states), function(x, n.states, tmp.model){
\end_layout

\begin_layout Plain Layout

    bounds <- ((x-1)*n.states+1):(x*n.states)
\end_layout

\begin_layout Plain Layout

    return(c(tmp.model[bounds], ""))
\end_layout

\begin_layout Plain Layout

  },
\end_layout

\begin_layout Plain Layout

                        rep("",(n.states+1)),
\end_layout

\begin_layout Plain Layout

                        n.states, tmp.model)
\end_layout

\begin_layout Plain Layout

  attr(final.model, "dim") <- NULL
\end_layout

\begin_layout Plain Layout

  return(final.model)
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

gen.datapoints <- function(data.df, resp=variable, enc=enc, scale=scale, posold=po
sold){
\end_layout

\begin_layout Plain Layout

  positions <- levels(factor(eval(substitute(posold), data.df)))
\end_layout

\begin_layout Plain Layout

  data.df <- expand.grid(resp=levels(factor(eval(substitute(resp), data.df))),
\end_layout

\begin_layout Plain Layout

                         enc=levels(factor(eval(substitute(enc), data.df))),
\end_layout

\begin_layout Plain Layout

                         scale=levels(factor(eval(substitute(scale), data.df))),
\end_layout

\begin_layout Plain Layout

                         posold=positions)
\end_layout

\begin_layout Plain Layout

  #remove are zero encodings with posold left/rigth
\end_layout

\begin_layout Plain Layout

  data.df <- data.df[!(data.df$enc==0 & data.df$posold %in% positions[c(1,length(pos
itions))]),]
\end_layout

\begin_layout Plain Layout

  #remove all encoded items without position
\end_layout

\begin_layout Plain Layout

  data.df <- data.df[!(data.df$enc!=0 & !(data.df$posold %in% positions[c(1,length(p
ositions))])),]
\end_layout

\begin_layout Plain Layout

  return(sort.data(data.df, resp, enc, scale, posold))
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

sort.data <- function(data.df, resp=variable, enc=enc, scale=scale, posold=posold)
{
\end_layout

\begin_layout Plain Layout

  order.vec = order(data.df[[as.character(substitute(posold))]], 
\end_layout

\begin_layout Plain Layout

                    data.df[[as.character(substitute(scale))]], 
\end_layout

\begin_layout Plain Layout

                    data.df[[as.character(substitute(enc))]], 
\end_layout

\begin_layout Plain Layout

                    data.df[[as.character(substitute(resp))]])
\end_layout

\begin_layout Plain Layout

  return(data.df[order.vec,])
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

extract.multi.mptinr.results <- function(model.name, mptinr.res){
\end_layout

\begin_layout Plain Layout

  ret <- data.frame(mptinr.res$goodness.of.fit$individual, mptinr.res$information.crit
eria$individual, t(mptinr.res$parameters$individual[,1,]))
\end_layout

\begin_layout Plain Layout

  row.names(ret) <- row.names(mptinr.res$data$observed$individual)
\end_layout

\begin_layout Plain Layout

  names(ret) <- paste(model.name, names(ret), sep="_")
\end_layout

\begin_layout Plain Layout

  return(ret)
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Model specifications
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

<<ModelSpecifications, eval=FALSE, echo=TRUE>>=
\end_layout

\begin_layout Plain Layout

MPT2HTM <- function(){
\end_layout

\begin_layout Plain Layout

  d.vec <- function(resp, enc, scale, posold, internal=FALSE){
\end_layout

\begin_layout Plain Layout

    enc.states <- levels(enc)[levels(enc)!=0]
\end_layout

\begin_layout Plain Layout

    d.par <- paste("d", rep(enc.states, each=length(levels(posold))), levels(posol
d), sep="")
\end_layout

\begin_layout Plain Layout

    confidence.vec <- ifelse(level(posold)==1, -level(resp)+length(levels(resp))+
1, level(resp))
\end_layout

\begin_layout Plain Layout

    ret <- ifelse(enc==0 | (!internal & confidence.vec <= length(levels(resp))/2)
, NA, d.par[(match(enc, enc.states)-1)*length(levels(posold))+level(posold)])
\end_layout

\begin_layout Plain Layout

    return(ret)
\end_layout

\begin_layout Plain Layout

  }
\end_layout

\begin_layout Plain Layout

  gr.vec <- function(resp, enc, scale, posold){
\end_layout

\begin_layout Plain Layout

    d.vec <- d.vec(resp, enc, scale, posold, internal=TRUE)
\end_layout

\begin_layout Plain Layout

    gr.par <- "gr"
\end_layout

\begin_layout Plain Layout

    ret <- ifelse(level(resp)>length(levels(resp))/2, 
\end_layout

\begin_layout Plain Layout

                  gr.par, 
\end_layout

\begin_layout Plain Layout

                  comp.prob.symbol(gr.par))
\end_layout

\begin_layout Plain Layout

    ret <- ifelse(is.na(d.vec), ret, paste(comp.prob.symbol(d.vec), ret, sep="*"))
\end_layout

\begin_layout Plain Layout

    return(ret)
\end_layout

\begin_layout Plain Layout

  }
\end_layout

\begin_layout Plain Layout

  dmap.vec <- function(resp, enc, scale, posold){
\end_layout

\begin_layout Plain Layout

    dmap.par <- paste("dm", rep(2:(length(levels(resp))/2)-1, length(levels(scale
))), rep(levels(scale), each=length(levels(resp))/2-1), sep="")
\end_layout

\begin_layout Plain Layout

    dmaps <- map.par.mpt.symbol(dmap.par, length(levels(scale)))[,c(1:(length(levels
(resp))/2),(length(levels(resp))/2):1)]
\end_layout

\begin_layout Plain Layout

    ret <- dmaps[(level(resp)-1)*length(levels(scale))+level(scale)]
\end_layout

\begin_layout Plain Layout

    return(ret)
\end_layout

\begin_layout Plain Layout

  }
\end_layout

\begin_layout Plain Layout

  gmap.vec <- function(resp, enc, scale, posold){
\end_layout

\begin_layout Plain Layout

    gmap.par <- paste("gm", rep(2:(length(levels(resp))/2)-1, length(levels(scale
))), rep(levels(scale), each=length(levels(resp))/2-1), sep="")
\end_layout

\begin_layout Plain Layout

    gmaps <- map.par.mpt.symbol(gmap.par, length(levels(scale)))[,c((length(levels(r
esp))/2):1,1:(length(levels(resp))/2))]
\end_layout

\begin_layout Plain Layout

    ret <- gmaps[(level(resp)-1)*length(levels(scale))+level(scale)]
\end_layout

\begin_layout Plain Layout

    return(ret)
\end_layout

\begin_layout Plain Layout

  }
\end_layout

\begin_layout Plain Layout

  model.description <- function(d.vec, gr.vec, dmap.vec, gmap.vec){
\end_layout

\begin_layout Plain Layout

    return(ifelse(is.na(d.vec), 
\end_layout

\begin_layout Plain Layout

                  paste(gr.vec, gmap.vec, sep="*"),
\end_layout

\begin_layout Plain Layout

                  paste(paste(d.vec, dmap.vec, sep="*"), paste(gr.vec, gmap.vec,
 sep="*"), sep="+")))
\end_layout

\begin_layout Plain Layout

  }
\end_layout

\begin_layout Plain Layout

  fit.call <- function(data, model.filename, parameter, ...){
\end_layout

\begin_layout Plain Layout

    return(fit.mpt(data, model.filename, ...))
\end_layout

\begin_layout Plain Layout

  }
\end_layout

\begin_layout Plain Layout

  return(list("MPT2HTM", d.vec, gr.vec, dmap.vec, gmap.vec, model.description,
 fit.call))
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

MPT1HTM2g <- function(){
\end_layout

\begin_layout Plain Layout

  d.vec <- function(resp, enc, scale, posold, internal=FALSE){
\end_layout

\begin_layout Plain Layout

    enc.states <- levels(enc)[levels(enc)!=0]
\end_layout

\begin_layout Plain Layout

    d.par <- paste("d", enc.states, sep="")
\end_layout

\begin_layout Plain Layout

    confidence.vec <- ifelse(level(posold)==1, -level(resp)+length(levels(resp))+
1, level(resp))
\end_layout

\begin_layout Plain Layout

    ret <- ifelse(enc==0 | (!internal & confidence.vec <= length(levels(resp))/2)
, NA, d.par[match(enc, enc.states)])
\end_layout

\begin_layout Plain Layout

    return(ret)
\end_layout

\begin_layout Plain Layout

  }
\end_layout

\begin_layout Plain Layout

  gr.vec <- function(resp, enc, scale, posold){
\end_layout

\begin_layout Plain Layout

    d.vec <- d.vec(resp, enc, scale, posold, internal=TRUE)
\end_layout

\begin_layout Plain Layout

    gr.par <- paste("gr", levels(scale), sep="")
\end_layout

\begin_layout Plain Layout

    ret <- ifelse(level(resp)>length(levels(resp))/2, 
\end_layout

\begin_layout Plain Layout

                  gr.par[level(scale)], 
\end_layout

\begin_layout Plain Layout

                  comp.prob.symbol(gr.par[level(scale)]))
\end_layout

\begin_layout Plain Layout

    ret <- ifelse(is.na(d.vec), ret, paste(comp.prob.symbol(d.vec), ret, sep="*"))
\end_layout

\begin_layout Plain Layout

    return(ret)
\end_layout

\begin_layout Plain Layout

  }
\end_layout

\begin_layout Plain Layout

  dmap.vec <- function(resp, enc, scale, posold){
\end_layout

\begin_layout Plain Layout

    dmap.par <- paste("dm", rep(2:(length(levels(resp))/2)-1, length(levels(scale
))), rep(levels(scale), each=length(levels(resp))/2-1), sep="")
\end_layout

\begin_layout Plain Layout

    dmaps <- map.par.mpt.symbol(dmap.par, length(levels(scale)))[,c(1:(length(levels
(resp))/2),(length(levels(resp))/2):1)]
\end_layout

\begin_layout Plain Layout

    ret <- dmaps[(level(resp)-1)*length(levels(scale))+level(scale)]
\end_layout

\begin_layout Plain Layout

    return(ret)
\end_layout

\begin_layout Plain Layout

  }
\end_layout

\begin_layout Plain Layout

  gmap.vec <- function(resp, enc, scale, posold){
\end_layout

\begin_layout Plain Layout

    gmap.par <- paste("gm", rep(2:(length(levels(resp))/2)-1, length(levels(scale
))), rep(levels(scale), each=length(levels(resp))/2-1), sep="")
\end_layout

\begin_layout Plain Layout

    gmaps <- map.par.mpt.symbol(gmap.par, length(levels(scale)))[,c((length(levels(r
esp))/2):1,1:(length(levels(resp))/2))]
\end_layout

\begin_layout Plain Layout

    ret <- gmaps[(level(resp)-1)*length(levels(scale))+level(scale)]
\end_layout

\begin_layout Plain Layout

    return(ret)
\end_layout

\begin_layout Plain Layout

  }
\end_layout

\begin_layout Plain Layout

  model.description <- function(d.vec, gr.vec, dmap.vec, gmap.vec){
\end_layout

\begin_layout Plain Layout

    return(ifelse(is.na(d.vec), 
\end_layout

\begin_layout Plain Layout

                  paste(gr.vec, gmap.vec, sep="*"),
\end_layout

\begin_layout Plain Layout

                  paste(paste(d.vec, dmap.vec, sep="*"), paste(gr.vec, gmap.vec,
 sep="*"), sep="+")))
\end_layout

\begin_layout Plain Layout

  }
\end_layout

\begin_layout Plain Layout

  fit.call <- function(data, model.filename, parameter, ...){
\end_layout

\begin_layout Plain Layout

    return(fit.mpt(data, model.filename, ...))
\end_layout

\begin_layout Plain Layout

  }
\end_layout

\begin_layout Plain Layout

  return(list("MPT1HTM2g", d.vec, gr.vec, dmap.vec, gmap.vec, model.description,
 fit.call))
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

EVSDT <- function(){
\end_layout

\begin_layout Plain Layout

  mu.vec <- function(resp, enc, scale, posold){
\end_layout

\begin_layout Plain Layout

    enc.states <- levels(enc)[levels(enc)!=0]
\end_layout

\begin_layout Plain Layout

    mu.par <- paste("mu", enc.states, sep="")
\end_layout

\begin_layout Plain Layout

    ret <- ifelse(enc==0, "0", mu.par[match(enc, enc.states)])
\end_layout

\begin_layout Plain Layout

    ret <- ifelse(level(posold)==1, paste("-", ret, sep=""), ret)
\end_layout

\begin_layout Plain Layout

    return(ret)
\end_layout

\begin_layout Plain Layout

  }
\end_layout

\begin_layout Plain Layout

  low.bound.vec <- function(resp, enc, scale, posold){
\end_layout

\begin_layout Plain Layout

    n.states <- length(levels(resp))
\end_layout

\begin_layout Plain Layout

    crit.par <- sdt.crit.par(n.states, scale)
\end_layout

\begin_layout Plain Layout

    ret <- ifelse(level(resp)==1, "-Inf", crit.par[(level(scale)-1)*(n.states)
 + level(resp)])
\end_layout

\begin_layout Plain Layout

    return(ret)
\end_layout

\begin_layout Plain Layout

  }
\end_layout

\begin_layout Plain Layout

  upper.bound.vec <- function(resp, enc, scale, posold){
\end_layout

\begin_layout Plain Layout

    n.states <- length(levels(resp))
\end_layout

\begin_layout Plain Layout

    crit.par <- sdt.crit.par(n.states, scale)
\end_layout

\begin_layout Plain Layout

    ret <- ifelse(level(resp)==n.states, "Inf", crit.par[(level(scale)-1)*(n.states
) + level(resp) + 1])
\end_layout

\begin_layout Plain Layout

    return(ret)
\end_layout

\begin_layout Plain Layout

  }
\end_layout

\begin_layout Plain Layout

  model.description <- function(mu.vec, low.bound.vec, upper.bound.vec){
\end_layout

\begin_layout Plain Layout

    return(paste("pnorm((", upper.bound.vec, "-1*", mu.vec, ")/sqrt(2))-pnorm((",
 low.bound.vec, "-1*", mu.vec, ")/sqrt(2))", sep=""))
\end_layout

\begin_layout Plain Layout

  }
\end_layout

\begin_layout Plain Layout

  fit.call <- function(data, model.filename, parameter, ...){
\end_layout

\begin_layout Plain Layout

    param.order <- parameter
\end_layout

\begin_layout Plain Layout

    lower.bound <- rep(-Inf, length(param.order))
\end_layout

\begin_layout Plain Layout

    upper.bound <- rep(Inf, length(param.order))
\end_layout

\begin_layout Plain Layout

    lower.bound[grep("c[^1].*", param.order)] <- 0
\end_layout

\begin_layout Plain Layout

    return(fit.model(data, model.filename, lower.bound=lower.bound, upper.bound=upper.
bound, ...))
\end_layout

\begin_layout Plain Layout

  }
\end_layout

\begin_layout Plain Layout

  return(list("EVSDT", mu.vec, low.bound.vec, upper.bound.vec, model.description,
 fit.call))
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

UVSDT <- function(){
\end_layout

\begin_layout Plain Layout

  mu.vec <- function(resp, enc, scale, posold){
\end_layout

\begin_layout Plain Layout

    enc.states <- levels(enc)[levels(enc)!=0]
\end_layout

\begin_layout Plain Layout

    mu.par <- paste("mu", enc.states, sep="")
\end_layout

\begin_layout Plain Layout

    ret <- ifelse(enc==0, "0", mu.par[match(enc, enc.states)])
\end_layout

\begin_layout Plain Layout

    ret <- ifelse(level(posold)==1, paste("-", ret, sep=""), ret)
\end_layout

\begin_layout Plain Layout

    return(ret)
\end_layout

\begin_layout Plain Layout

  }
\end_layout

\begin_layout Plain Layout

  sd.vec <- function(resp, enc, scale, posold){
\end_layout

\begin_layout Plain Layout

    enc.states <- levels(enc)[levels(enc)!=0]
\end_layout

\begin_layout Plain Layout

    sd.par <- paste("sd", enc.states, sep="")
\end_layout

\begin_layout Plain Layout

    ret <- ifelse(enc==0, "1", sd.par[match(enc, enc.states)])
\end_layout

\begin_layout Plain Layout

    return(ret)
\end_layout

\begin_layout Plain Layout

  }
\end_layout

\begin_layout Plain Layout

  low.bound.vec <- function(resp, enc, scale, posold){
\end_layout

\begin_layout Plain Layout

    n.states <- length(levels(resp))
\end_layout

\begin_layout Plain Layout

    crit.par <- sdt.crit.par(n.states, scale)
\end_layout

\begin_layout Plain Layout

    ret <- ifelse(level(resp)==1, "-Inf", crit.par[(level(scale)-1)*(n.states)
 + level(resp)])
\end_layout

\begin_layout Plain Layout

    return(ret)
\end_layout

\begin_layout Plain Layout

  }
\end_layout

\begin_layout Plain Layout

  upper.bound.vec <- function(resp, enc, scale, posold){
\end_layout

\begin_layout Plain Layout

    n.states <- length(levels(resp))
\end_layout

\begin_layout Plain Layout

    crit.par <- sdt.crit.par(n.states, scale)
\end_layout

\begin_layout Plain Layout

    ret <- ifelse(level(resp)==n.states, "Inf", crit.par[(level(scale)-1)*(n.states
) + level(resp) + 1])
\end_layout

\begin_layout Plain Layout

    return(ret)
\end_layout

\begin_layout Plain Layout

  }
\end_layout

\begin_layout Plain Layout

  model.description <- function(mu.vec, sd.vec, low.bound.vec, upper.bound.vec){
\end_layout

\begin_layout Plain Layout

    return(paste("pnorm(", upper.bound.vec, ",", mu.vec, ",sqrt(1^2+", sd.vec,
 "^2))-pnorm(", low.bound.vec, ",", mu.vec, ",sqrt(1^2+", sd.vec, "^2))", sep=""))
\end_layout

\begin_layout Plain Layout

  }
\end_layout

\begin_layout Plain Layout

  fit.call <- function(data, model.filename, parameter, ...){
\end_layout

\begin_layout Plain Layout

    param.order <- parameter
\end_layout

\begin_layout Plain Layout

    lower.bound <- rep(-Inf, length(param.order))
\end_layout

\begin_layout Plain Layout

    upper.bound <- rep(Inf, length(param.order))
\end_layout

\begin_layout Plain Layout

    lower.bound[grep("c[^1].*", param.order)] <- 0
\end_layout

\begin_layout Plain Layout

    lower.bound[grep("sd.*", param.order)] <- 0
\end_layout

\begin_layout Plain Layout

    return(fit.model(data, model.filename, use.gradient=FALSE, lower.bound=lower.boun
d, upper.bound=upper.bound, ...))
\end_layout

\begin_layout Plain Layout

  }
\end_layout

\begin_layout Plain Layout

  return(list("UVSDT", mu.vec, sd.vec, low.bound.vec, upper.bound.vec, model.descriptio
n, fit.call))
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

map.par.mpt.symbol <- function(map.par, n.scales){
\end_layout

\begin_layout Plain Layout

  n.states.half <- length(map.par)/n.scales+1
\end_layout

\begin_layout Plain Layout

  maps <- array(rep("1", n.states.half*n.scales), dim=c(n.scales, n.states.half))
\end_layout

\begin_layout Plain Layout

  for(s in 1:n.scales){
\end_layout

\begin_layout Plain Layout

    offset <- (s-1)*(n.states.half-1)
\end_layout

\begin_layout Plain Layout

    offset.maps <- (s-1)*(n.states.half)
\end_layout

\begin_layout Plain Layout

    maps[s,2:n.states.half] <- cumop.symbol(comp.prob.symbol(map.par[(offset+1):(offse
t+n.states.half-1)]), "*", no.paren=TRUE)
\end_layout

\begin_layout Plain Layout

    maps[s,2:n.states.half-1] <- paste(maps[s,2:n.states.half-1],
\end_layout

\begin_layout Plain Layout

                                       map.par[(offset+1):(offset+n.states.half-1)]
, 
\end_layout

\begin_layout Plain Layout

                                       sep="*")
\end_layout

\begin_layout Plain Layout

  }
\end_layout

\begin_layout Plain Layout

  return(maps)
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

sdt.crit.par <- function(n.states, scale){
\end_layout

\begin_layout Plain Layout

  crit.par <- paste("c", rep(1:(n.states-1), length(levels(scale))), rep(levels(sc
ale), each=n.states-1), sep="")
\end_layout

\begin_layout Plain Layout

  crit <- array(NA, dim=c(n.states, length(levels(scale))))
\end_layout

\begin_layout Plain Layout

  for(s in 1:length(levels(scale))){
\end_layout

\begin_layout Plain Layout

    offset <- (s-1)*(n.states-1)
\end_layout

\begin_layout Plain Layout

    crit[2:n.states, s] <- cumop.symbol(crit.par[(offset+1):(offset+n.states-1)],
 "+")
\end_layout

\begin_layout Plain Layout

  }
\end_layout

\begin_layout Plain Layout

  return(crit)
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

level <- function(factor){
\end_layout

\begin_layout Plain Layout

  return(match(factor, levels(factor)))
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

cumop.symbol <- function(symbols, op, no.paren=FALSE){
\end_layout

\begin_layout Plain Layout

  cumop <- c()
\end_layout

\begin_layout Plain Layout

  for(i in 1:length(symbols)){
\end_layout

\begin_layout Plain Layout

    tmp.cumop <- do.call(paste, c(as.list(symbols[1:i]), list(sep=op)))
\end_layout

\begin_layout Plain Layout

    cumop[i] <- ifelse(no.paren, tmp.cumop, paste("(", tmp.cumop, ")", sep=""))
\end_layout

\begin_layout Plain Layout

  }
\end_layout

\begin_layout Plain Layout

  return(cumop)
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

comp.prob.symbol <- function(symbols){
\end_layout

\begin_layout Plain Layout

  return(paste("(1-", symbols, ")", sep=""))
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\end_body
\end_document
